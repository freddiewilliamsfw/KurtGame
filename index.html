<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
</head>
<body>
    <script>

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 1000,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 300 },
            debug: false
        }
    },
    cameras: {
        main: {
            height: 1000,
            width: 800
                }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

const game = new Phaser.Game(config);

let player;
let platforms;
let protein;
let gameOver = false;
let ground;
let highestPlatformY;
let score = 0;
let scoreText;
const PLATFORM_VERTICAL_SPACING = 150;

function preload() {
    this.load.image('ground', 'Assets/platform.png');
    this.load.image('dumbell', 'Assets/dumbell.png');
    this.load.image('kurt', 'Assets/kurt.png');
    this.load.image('protein', 'Assets/protein.png');
    this.load.image('background', 'Assets/background.png');
}

function create() {

    this.add.image(400, 500, 'background')

    platforms = this.physics.add.staticGroup();

      // Set world bounds
    this.physics.world.setBounds(0, -Number.MAX_SAFE_INTEGER, 800, Number.MAX_SAFE_INTEGER * 2);
    
    // Player creation and physics
    let startPlatform = platforms.getChildren()[0]; // Get the first platform
    player = this.physics.add.sprite(startPlatform.x, startPlatform.y - 50, 'kurt');
    player.setBounce(0.2);
    player.setCollideWorldBounds(true);

     // Initialize platforms
    initializePlatforms(this);

    // Create the protein
    createProtein(this);

    // Set up camera to follow player
    this.cameras.main.startFollow(player);
    this.cameras.main.setDeadzone(0, 200);

    // Adjust camera bounds
    this.cameras.main.setBounds(0, -Number.MAX_SAFE_INTEGER, 800, Number.MAX_SAFE_INTEGER * 2);

    });

    // Program collisions
    this.physics.add.collider(player, platforms);
    this.physics.add.overlap(player, protein, reachGoal, null, this);

    // Create on-screen score
    scoreText = this.add.text(16, 16, 'Score: 0', { fontSize: '32px', fill: '#000' });
    scoreText.setScrollFactor(0); // This makes the text stay on screen
        
}
function initializePlatforms(scene) {
    highestPlatformY = 950;
    for (let i = 0; i < 10; i++) { // Create initial 10 platforms
        const newPlatform = generatePlatform(scene, highestPlatformY);
        platforms.add(newPlatform);
        highestPlatformY -= PLATFORM_VERTICAL_SPACING;
    }
}

function generatePlatform(scene, y) {
    const x = Phaser.Math.Between(50, 750);
    return scene.physics.add.staticImage(x, y, 'dumbell');
}

function update() {
if (gameOver) {
        return;

}

    const cursors = this.input.keyboard.createCursorKeys();

    if (cursors.left.isDown) {
        player.setVelocityX(-160);
        player.setFlipX(true);  // Flip the sprite to face left
    } else if (cursors.right.isDown) {
        player.setVelocityX(160);
        player.setFlipX(false);  // Return the sprite to its original orientation
    } else {
        player.setVelocityX(0);
        // Optionally, you can add an idle animation or change the frame here
    }

    if (cursors.up.isDown && player.body.touching.down) {
        player.setVelocityY(-330);
    }

    const lowestPlatformY = Math.max(...platforms.children.entries.map(p => p.y));
    if (player.y > lowestPlatformY + 200) { // 200 is an example value, adjust as needed
        gameOverHandler.call(this);
    }
    
    
    // Generate new platforms as the camera moves up
     if (this.cameras.main.scrollY < highestPlatformY - 500) {
        const newPlatform = generatePlatform(this, highestPlatformY - PLATFORM_VERTICAL_SPACING);
        platforms.add(newPlatform);
        highestPlatformY -= PLATFORM_VERTICAL_SPACING;
    }

    // Remove platforms that are too low
    platforms.children.entries.forEach(platform => {
        if (platform.y > this.cameras.main.scrollY + 1100) {
            platforms.remove(platform, true, true);
        }
    });
}

function createProtein(scene) {
    protein = scene.physics.add.staticImage(
        Phaser.Math.Between(50, 750),
        highestPlatformY - PLATFORM_VERTICAL_SPACING,
        'protein'
    );
}
    
function reachGoal(player, protein) {
    console.log('reachGoal function called');
    score += 10;
    scoreText.setText('Score: ' + score);

    // Remove collected protein
    protein.disableBody(true, true);

    // Generate a new protein at a higher position
    const newProteinY = protein.y - Phaser.Math.Between(300, 500);
    const newProtein = this.physics.add.staticImage(
        Phaser.Math.Between(50, 750),
        newProteinY,
        'protein'
    );
    this.physics.add.overlap(player, newProtein, reachGoal, null, this);

    const glugText = this.add.text(400, player.y - 100, 'GLUG GLUG', {
        fontSize: '24px',
        fill: '#ff0000'
    });
    glugText.setOrigin(0.5);
    this.tweens.add({
        targets: glugText,
        alpha: 0,
        y: glugText.y - 50,
        duration: 1000,
        ease: 'Power2',
        onComplete: () => glugText.destroy()
    });
}

function gameOverHandler() {
    gameOver = true;
    this.physics.pause();
    player.setTint(0xff0000);

    let gameOverText = this.add.text(400, this.cameras.main.scrollY + 500, 'GAME OVER', { fontSize: '64px', fill: '#000' });
    gameOverText.setOrigin(0.5);
    gameOverText.setScrollFactor(0);

    let restartButton = this.add.text(400, this.cameras.main.scrollY + 600, 'Restart', { fontSize: '32px', fill: '#000' });
    restartButton.setOrigin(0.5);
    restartButton.setScrollFactor(0);
    restartButton.setInteractive();
    restartButton.on('pointerdown', () => {
        gameOver = false;
        score = 0;
        this.scene.restart();
    });
}

</script>
</body>
</html>
